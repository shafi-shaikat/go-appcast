package appcast

import (
	"encoding/xml"
	"fmt"
	"regexp"
)

// SparkleRSSFeedAppcaster is the interface that wraps the SparkleRSSFeedAppcast
// methods.
type SparkleRSSFeedAppcaster interface {
	Appcaster
}

// A SparkleRSSFeedAppcast represents appcast for "Sparkle RSS Feed" that is
// generated by Sparkle Framework.
type SparkleRSSFeedAppcast struct {
	Appcast
}

// A SparkleRSSFeedXML represents an RSS itself.
type SparkleRSSFeedXML struct {
	Items []SparkleRSSFeedXMLItem `xml:"channel>item"`
}

// A SparkleRSSFeedXMLItem represents an RSS item.
type SparkleRSSFeedXMLItem struct {
	Title                string                     `xml:"title"`
	Description          string                     `xml:"description"`
	MinimumSystemVersion string                     `xml:"minimumSystemVersion"`
	PubDate              string                     `xml:"pubDate"`
	Enclosure            SparkleRSSFeedXMLEnclosure `xml:"enclosure"`
	Version              string                     `xml:"version"`
	ShortVersionString   string                     `xml:"shortVersionString"`
}

// A SparkleRSSFeedXMLEnclosure represents an RSS enclosure in item.
type SparkleRSSFeedXMLEnclosure struct {
	Version            string `xml:"version,attr"`
	ShortVersionString string `xml:"shortVersionString,attr"`
	URL                string `xml:"url,attr"`
	Length             int    `xml:"length,attr"`
	Type               string `xml:"type,attr"`
}

// UnmarshalReleases unmarshals the Appcast.source.content into the
// Appcast.releases for the "Sparkle RSS Feed" provider.
func (a *SparkleRSSFeedAppcast) UnmarshalReleases() error {
	var x SparkleRSSFeedXML
	var version, build string

	xml.Unmarshal(a.source.Content(), &x)

	items := make([]Release, len(x.Items))
	for i, item := range x.Items {
		if item.Enclosure.ShortVersionString == "" && item.ShortVersionString != "" {
			version = item.ShortVersionString
		} else {
			version = item.Enclosure.ShortVersionString
		}

		if item.Enclosure.Version == "" && item.Version != "" {
			build = item.Version
		} else {
			build = item.Enclosure.Version
		}

		if version == "" && build == "" {
			return fmt.Errorf("version is required, but it's not specified in release #%d", i+1)
		} else if version == "" && build != "" {
			version = build
		}

		// new release
		r, err := NewRelease(version, build)
		if err != nil {
			return err
		}

		r.SetTitle(item.Title)
		r.SetDescription(item.Description)
		r.ParsePublishedDateTime(item.PubDate)

		// prerelease
		if r.Version().Prerelease() != "" {
			r.SetIsPreRelease(true)
		}

		// downloads
		d := NewDownload(item.Enclosure.URL, item.Enclosure.Type, item.Enclosure.Length)
		r.AddDownload(*d)

		items[i] = *r
	}

	a.releases = items

	return nil
}

// Uncomment uncomments XML tags in SparkleRSSFeedAppcast.source.content.
func (a *SparkleRSSFeedAppcast) Uncomment() error {
	if a.source == nil || len(a.source.Content()) == 0 {
		return fmt.Errorf("no source")
	}

	regex := regexp.MustCompile(`(<!--([[:space:]]*)?)|(([[:space:]]*)?-->)`)
	if regex.Match(a.source.Content()) {
		a.source.SetContent(regex.ReplaceAll(a.source.Content(), []byte("")))
	}

	return nil
}
